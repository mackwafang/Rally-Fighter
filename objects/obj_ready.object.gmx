<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>time = 360;
health = 100;
global.boost = 100;
if(instance_exists(obj_finish)){
    with(obj_finish) {instance_destroy();}
}
//addRacer = min(((obj_wall2.x+obj_wall.x) div 50)+global.level,24);
addRacer = min(global.level+10,24);
view_yview[0] = 32-time;
obj_control.randomMove = background_x[1];
if(background_index[0] == bkg_water){
    background_index[3] = bkg_bridge_fence_r;
    background_index[2] = bkg_bridge_fence_l;
    //background_x[2] = obj_wall.x-26;
}
else{
    background_index[3] = bkg_fence;
    background_index[2] = bkg_fence;
    //background_x[2] = obj_wall.x;
}
switch(background_index[1]){
    case bkg_road1: horAdd = 2; break;
    case bkg_road1_m: horAdd = 1; break;
    case bkg_road2: horAdd = 4; break;
    case bkg_road2_m: horAdd = 2; break;
    case bkg_road3: horAdd = 8; break;
    case bkg_road3_m: horAdd = 4; break;
}
/*if(global.isMedian){
    wall = ((obj_wall2.x+obj_wall.x)/2)-24;
}
else{
    wall = obj_wall.x;
}*/
//obj_player.x = wall+60;
obj_player.x = roadInitialX;
obj_player.y = 256;
instance_destroy(obj_road);
initRoad();
var wall, spawnWidth;
switch(getRoadWidth(obj_road.image_index)) {
    case 0:
        wall = -46;
        spawnWidth = 2;
        break;
    case 1:
        wall = -70;
        spawnWidth = 3;
        break;
    case -1:
        wall = -46;
        spawnWidth = 3;
        break;
    case 2:
        wall = -94
        spawnWidth = 4;
        break;
    case -2:
        wall = -46;
        spawnWidth = 4;
        break;
    case 3:
        wall = -148;
        spawnWidth = 2;
        break;
    case -3:
        wall = 48;
        spawnWidth = 2;
        break;
}
for(i = 0; i &lt; addRacer; i += 1){
    xx = roadInitialX+wall+36+((i mod spawnWidth)*24);
    yy = 192-(i*64);
    with(instance_create(xx,yy,obj_npc_racer)){
        if (carID == 1) {
            view_object[0] = self;
        }
        carID = other.i+1;
    }
}
initRanking();
/********************* Buffers *********************/
global.saveBuffer = buffer_create(1024,buffer_grow,1);
global.stateSaved = true;
buffer_seek(global.saveBuffer,buffer_seek_start,0);
game_save_buffer(global.saveBuffer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var wv, hv;
wv = view_wport[0];
hv = view_hport[0];
time --;
if(obj_control.blackFade &lt; 180){
    obj_control.blackFade ++;
}
else{
    obj_control.blackFade = 180;
}
with(obj_npc_racer) {condition = 25;}
if(time &lt;= 0) {
    instance_destroy();
    /*for(i = -256; i &lt;= 0; i += 32){
        if(obj_control.beachSide == 1){
            with(instance_position(i,obj_wall2.x+32,obj_wave)){
                instance_destroy();
            }
        }
        else{
            with(instance_position(i,obj_wall.x-32,obj_wave)){
                instance_destroy();
            }
        }
    }*/
    obj_player.brake = false;
    obj_control.blackFade = 0;
}
draw_set_font(global.gameFont);
draw_set_valign(fa_center);
draw_set_halign(fa_middle);
draw_set_alpha(0.5);
draw_rectangle_colour(0,0,wv,hv,0,0,0,0,false);
draw_set_alpha(1);

draw_sprite_ext(spr_get_ready,time/36,wv/2,hv*0.4,2,2,0,white,1);
if(time &lt; 180){
    draw_text_transformed_colour(wv/2,hv/2,(time div 60)+1,3,3,0,white,white,white,white,1);
}
if(global.level &lt;= 2){
    draw_text_transformed_colour(wv/2,(2*hv/3),"Left Key: Turn Left#Right Key: Turn Right#Z: Accelerate#X: Boost#C: Brake",2,2,0,white,white,white,white,1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
